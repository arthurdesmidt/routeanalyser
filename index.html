<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RouteTeller â€” Roundabouts & Traffic Lights (v3)</title>
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#ffffff">
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    :root{--bg:#ffffff;--card:#ffffff;--accent:#0078ff;--muted:#666;}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, 'Helvetica Neue', Arial}
    body{background:var(--bg);color:#0b0b0b}
    #map{height:56vh}
    .topbar{position:absolute;left:12px;top:12px;z-index:1000;background:var(--card);padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.08);min-width:320px}
    .topbar h1{margin:0;font-size:15px}
    .stats{margin-top:8px;font-size:14px}
    .btn{display:inline-block;padding:6px 10px;border-radius:6px;background:var(--accent);color:white;text-decoration:none;margin-top:8px;cursor:pointer}
    .muted{color:var(--muted);font-size:13px}
    .footerNote{position:absolute;left:12px;bottom:12px;z-index:1000;background:rgba(255,255,255,0.95);padding:8px;border-radius:8px;box-shadow:0 4px 10px rgba(0,0,0,0.06);font-size:13px}
    .panel{padding:12px}
    table{width:100%;border-collapse:collapse;font-size:13px}
    th,td{padding:8px;border-bottom:1px solid #eee;text-align:left}
    th{background:#fafafa}
    .controls{margin-bottom:8px}
    .export-btn{display:inline-block;padding:6px 10px;border-radius:6px;background:#2f855a;color:white;text-decoration:none;margin-right:6px;cursor:pointer}
    .searchRow{margin-top:8px;display:flex;gap:8px}
    .searchRow input{flex:1;padding:6px;border-radius:6px;border:1px solid #ddd}
    .suggestions{position:relative}
    .suggestList{position:absolute;left:0;right:0;background:white;border:1px solid #eee;max-height:200px;overflow:auto;z-index:2000;border-radius:6px;margin-top:4px}
    .suggestItem{padding:8px;border-bottom:1px solid #f6f6f6;cursor:pointer}
    .suggestItem:hover{background:#f8faff}
    @media (max-width:700px){.topbar{min-width:220px}table{font-size:12px}}
  </style>
</head>
<body>
  <div id="map"></div>

  <div class="topbar" id="panel">
    <h1>RouteTeller v3</h1>
    <div class="muted">Type addresses OR click on the map to set start/end.</div>

    <div class="searchRow">
      <div style="flex:1">
        <label class="muted">Start</label>
        <div class="suggestions">
          <input id="startInput" placeholder="Type start address..." autocomplete="off">
          <div id="startSug" class="suggestList" style="display:none"></div>
        </div>
      </div>
      <div style="flex:1">
        <label class="muted">End</label>
        <div class="suggestions">
          <input id="endInput" placeholder="Type destination..." autocomplete="off">
          <div id="endSug" class="suggestList" style="display:none"></div>
        </div>
      </div>
    </div>

    <div class="stats" id="stats">ðŸŒ€ Roundabouts: â€” &nbsp;&nbsp; ðŸš¦ Traffic lights: â€” &nbsp;&nbsp; ðŸ›‘ Stops: â€” &nbsp;&nbsp; ðŸš¶ Crossings: â€”</div>
    <div style="margin-top:8px">
      <div id="routeBtn" class="btn">Build route</div>
      <div id="clearBtn" class="btn" style="background:#888;margin-left:8px">Clear</div>
    </div>
    <div class="muted" style="margin-top:6px">Uses OpenStreetMap data (Overpass) & OSRM routing. Buffer: <input id="bufferInput" type="number" value="2" style="width:60px"> m (2 m default; roundabout buffer uses 10 m)</div>
  </div>

  <div class="footerNote">Tip: add to home screen to use like an app</div>

  <div class="panel">
    <div class="controls">
      <div id="exportCsv" class="export-btn">Export CSV</div>
      <div id="exportJson" class="export-btn" style="background:#0b5cff">Export JSON</div>
    </div>

    <div style="max-height:36vh;overflow:auto;border:1px solid #f0f0f0;border-radius:6px;padding:6px">
      <table id="stepsTable">
        <thead>
          <tr><th>#</th><th>Instruction</th><th>Street</th><th>Direction</th><th>Distance (m)</th><th>Duration (s)</th><th>Lat, Lon</th><th>Found Object Type(s)</th><th>Step Type</th></tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <script>
    const map = L.map('map').setView([52.3702, 4.8952], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {maxZoom:19}).addTo(map);

    let startPoint = null;
    let endPoint = null;
    let markers = [];
    let routeLayer = null;

    const startInput = document.getElementById('startInput');
    const endInput = document.getElementById('endInput');
    const startSug = document.getElementById('startSug');
    const endSug = document.getElementById('endSug');

    async function nominatimSearch(q) {
      if(!q || q.length<3) return [];
      const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&addressdetails=1&limit=6`;
      const res = await fetch(url, {headers:{'Accept':'application/json','Referer':location.origin}});
      if(!res.ok) return [];
      const json = await res.json();
      return json;
    }

    function showSuggestions(list, container, inputEl, setFn){
      container.innerHTML='';
      if(!list || list.length===0){ container.style.display='none'; return; }
      list.forEach(item => {
        const div = document.createElement('div');
        div.className='suggestItem';
        div.textContent = item.display_name;
        div.addEventListener('click', () => {
          inputEl.value = item.display_name;
          container.style.display='none';
          setFn([parseFloat(item.lon), parseFloat(item.lat)]);
        });
        container.appendChild(div);
      });
      container.style.display='block';
    }

    let searchTimerStart = null;
    startInput.addEventListener('input', (e)=>{
      clearTimeout(searchTimerStart);
      searchTimerStart = setTimeout(async ()=>{
        const res = await nominatimSearch(e.target.value);
        showSuggestions(res, startSug, startInput, (pt)=>{ setStart(pt); });
      }, 300);
    });
    let searchTimerEnd = null;
    endInput.addEventListener('input', (e)=>{
      clearTimeout(searchTimerEnd);
      searchTimerEnd = setTimeout(async ()=>{
        const res = await nominatimSearch(e.target.value);
        showSuggestions(res, endSug, endInput, (pt)=>{ setEnd(pt); });
      }, 300);
    });

    function setStart(lonlat){
      startPoint = lonlat;
      addMarker([lonlat[1], lonlat[0]], 'start');
      map.setView([lonlat[1], lonlat[0]], 14);
    }
    function setEnd(lonlat){
      endPoint = lonlat;
      addMarker([lonlat[1], lonlat[0]], 'end');
      map.setView([lonlat[1], lonlat[0]], 14);
    }

    function addMarker(latlng, tag){
      const m = L.marker(latlng).addTo(map);
      m.bindPopup(tag || 'point');
      markers.push(m);
    }

    map.on('click', (e)=>{
      if(!startPoint){ setStart([e.latlng.lng, e.latlng.lat]); startInput.value = 'Map point'; return; }
      if(!endPoint){ setEnd([e.latlng.lng, e.latlng.lat]); endInput.value = 'Map point'; return; }
      clearAll();
      setStart([e.latlng.lng, e.latlng.lat]); startInput.value='Map point';
    });

    document.getElementById('clearBtn').addEventListener('click', clearAll);
    document.getElementById('routeBtn').addEventListener('click', ()=>{ if(startPoint && endPoint) buildRoute(); else alert('Please set both start and end (type addresses or click on map).'); });
    document.getElementById('exportCsv').addEventListener('click', exportCSV);
    document.getElementById('exportJson').addEventListener('click', exportJSON);

    function clearAll(){
      markers.forEach(m=>map.removeLayer(m)); markers=[];
      if(routeLayer) { map.removeLayer(routeLayer); routeLayer=null; }
      if(window._osmMarkers) window._osmMarkers.forEach(m=>map.removeLayer(m)); window._osmMarkers=[];
      document.querySelector('#stepsTable tbody').innerHTML='';
      document.getElementById('stats').innerHTML = 'ðŸŒ€ Roundabouts: â€” &nbsp;&nbsp; ðŸš¦ Traffic lights: â€” &nbsp;&nbsp; ðŸ›‘ Stops: â€” &nbsp;&nbsp; ðŸš¶ Crossings: â€”';
      startPoint = endPoint = null;
      startInput.value=''; endInput.value='';
    }

    async function buildRoute(){
      try{
        const route = await fetchRouteWithSteps(startPoint, endPoint);
        drawRoute(route.geometry);
        const bufferMeters = Number(document.getElementById('bufferInput').value) || 2;
        const analysis = await analyzeStepsWithOverpass(route.steps, bufferMeters);
        renderTable(analysis);
        updateSummary(analysis);
      }catch(err){
        console.error(err);
        alert('Routing / analysis error: ' + err.message);
      }
    }

    async function fetchRouteWithSteps(start, end){
      const url = `https://router.project-osrm.org/route/v1/driving/${start[0]},${start[1]};${end[0]},${end[1]}?overview=full&geometries=geojson&steps=true`;
      const res = await fetch(url);
      if(!res.ok) throw new Error('OSRM routing failed');
      const data = await res.json();
      if(!data.routes || data.routes.length===0) throw new Error('No route found');
      const route = data.routes[0];
      const steps = [];
      route.legs.forEach(leg=> leg.steps.forEach(s=> steps.push(s)));
      return {geometry: route.geometry, steps, distance: route.distance, duration: route.duration};
    }

    function drawRoute(geojson){
      if(routeLayer) map.removeLayer(routeLayer);
      routeLayer = L.geoJSON(geojson, {style:{color:'#0078ff',weight:5,opacity:0.9}}).addTo(map);
      map.fitBounds(routeLayer.getBounds(), {padding:[40,40]});
    }

    async function analyzeStepsWithOverpass(steps, bufferMeters){
      const points = [];
      steps.forEach((s, idx)=>{
        const man = s.maneuver || {};
        if(man.location) points.push({idx, lon:man.location[0], lat:man.location[1], instruction: man.instruction || s.name || '', stepType: man.type || ''});
        else if(s.intersections && s.intersections.length) s.intersections.forEach(inter=> points.push({idx, lon:inter.location[0], lat:inter.location[1], instruction: s.name || '', stepType: inter.type || ''}));
      });
      if(points.length===0) throw new Error('No maneuver points found');

      const uniq = {};
      points.forEach(p=>{
        const key = `${p.lat.toFixed(6)},${p.lon.toFixed(6)}`;
        if(!uniq[key]) uniq[key] = {lat:p.lat, lon:p.lon, idxs:[p.idx], stepTypes:[p.stepType]};
        else { uniq[key].idxs.push(p.idx); if(p.stepType) uniq[key].stepTypes.push(p.stepType); }
      });
      const pts = Object.values(uniq).slice(0, 120);

      const tags = [
        {q: 'node["highway"="traffic_signals"]', id:'traffic_signals'},
        {q: 'node["highway"="stop"]', id:'stops'},
        {q: 'node["junction"="roundabout"]', id:'roundabouts'},
        {q: 'node["highway"="crossing"]', id:'crossings'}
      ];
      let query = '[out:json][timeout:25];(';
      pts.forEach(p=>{
        tags.forEach(t=> query += `${t.q}(around:${Math.max(50, bufferMeters+20)},${p.lat},${p.lon});`);
      });
      query += ');out body;';

      const overpassRes = await fetch('https://overpass-api.de/api/interpreter', {method:'POST', body: query});
      if(!overpassRes.ok) throw new Error('Overpass query failed');
      const overpassJson = await overpassRes.json();
      const elems = (overpassJson.elements || []).map(el => ({id:el.id, lat:el.lat, lon:el.lon, tags:el.tags||{}}));

      if(window._osmMarkers) window._osmMarkers.forEach(m=>map.removeLayer(m)); window._osmMarkers=[];

      const perStep = steps.map((s, idx) => {
        const man = s.maneuver || {};
        const latlon = man.location ? (man.location[1].toFixed(6)+', '+man.location[0].toFixed(6)) : '';
        return {index: idx+1, instruction: man.instruction || s.name || '', street: s.name || '', direction: (man.type || '') + (man.modifier?(' '+man.modifier):''), distance: Math.round(s.distance||0), duration: Math.round(s.duration||0), latlon, found: [], stepType: man.type || ''};
      });

      // deduplicate roundabouts by coordinate/id
      const foundRoundabouts = new Map();

      // build routeLine for projection checks
      const routeLine = routeLayer ? turf.lineString(routeLayer.toGeoJSON().features[0].geometry.coordinates) : null;

      elems.forEach(el => {
        // reject if too far from centerline (helps avoid opposite side of road)
        try{
          if(routeLine){
            const pt = turf.point([el.lon, el.lat]);
            const dline = turf.pointToLineDistance(pt, routeLine, {units:'meters'});
            if(dline > Math.max(3, bufferMeters+1)) return;
          }
        } catch(e){ /* ignore turf errors */ }

        // find best step by distance
        let best = {idx:-1, dist:1e9};
        perStep.forEach((ps, i) => {
          const step = steps[i];
          const man = step.maneuver || {};
          let targetPt = null;
          if(man.location) targetPt = [man.location[0], man.location[1]];
          else if(step.geometry && step.geometry.coordinates && step.geometry.coordinates.length) targetPt = step.geometry.coordinates[Math.floor(step.geometry.coordinates.length/2)];
          if(targetPt){
            const d = turf.distance(turf.point([el.lon,el.lat]), turf.point([targetPt[0], targetPt[1]]), {units:'meters'});
            if(d < best.dist){ best = {idx:i, dist:d}; }
          }
        });
        if(best.idx<0) return;
        const tolerance = 6;
        if(best.dist > (bufferMeters + tolerance)) return;

        // classify types
        const types = [];
        if(el.tags.highway === 'traffic_signals') types.push('traffic_signal');
        if(el.tags.highway === 'stop') types.push('stop');
        if(el.tags.junction === 'roundabout') types.push('roundabout');
        if(el.tags.highway === 'crossing') types.push('crossing');
        if(types.length===0){
          if(el.tags.traffic_signals) types.push('traffic_signal');
        }
        if(types.length===0) types.push('other');

        // handle roundabout deduplication
        if(types.includes('roundabout')){
          const key = `${el.lat.toFixed(6)}_${el.lon.toFixed(6)}_${el.id}`;
          if(foundRoundabouts.has(key)) return; // already counted and mapped
          foundRoundabouts.set(key, true);
        }

        perStep[best.idx].found.push({id:el.id, types, lat:el.lat, lon:el.lon, dist: Math.round(best.dist)});
      });

      // Additionally, check OSRM step types for roundabout and mark them if close to any rotonde within 10m
      perStep.forEach((ps, i) => {
        if(ps.stepType === 'roundabout'){
          // find any roundabout OSM node within 10m of maneuver
          const manLoc = steps[i].maneuver && steps[i].maneuver.location ? steps[i].maneuver.location : null;
          if(manLoc){
            const manPt = turf.point([manLoc[0], manLoc[1]]);
            let found = false;
            elems.forEach(el => {
              if(el.tags && el.tags.junction === 'roundabout'){
                const d = turf.distance(manPt, turf.point([el.lon, el.lat]), {units:'meters'});
                if(d <= 10){
                  // ensure we don't double-count the same roundabout node
                  const key = `${el.lat.toFixed(6)}_${el.lon.toFixed(6)}_${el.id}`;
                  if(!foundRoundabouts.has(key)){
                    foundRoundabouts.set(key, true);
                    perStep[i].found.push({id:el.id, types:['roundabout'], lat:el.lat, lon:el.lon, dist: Math.round(d)});
                  } else {
                    // already counted by earlier logic; ensure this step references it too (but don't increment summary twice)
                    perStep[i].found.push({id:el.id, types:['roundabout'], lat:el.lat, lon:el.lon, dist: Math.round(d)});
                  }
                }
              }
            });
          }
        }
      });

      // place markers for found elements (unique by id)
      const placed = new Set();
      perStep.forEach(ps => ps.found.forEach(f => {
        if(placed.has(f.id)) return;
        placed.add(f.id);
        let color='#666', label='Other';
        if(f.types.includes('traffic_signal')){ color='#e91e63'; label='Traffic light'; }
        else if(f.types.includes('stop')){ color='#d9534f'; label='Stop'; }
        else if(f.types.includes('roundabout')){ color='#ff9f00'; label='Roundabout'; }
        else if(f.types.includes('crossing')){ color='#2f855a'; label='Crossing'; }
        const m = L.circleMarker([f.lat, f.lon], {radius:7, fillColor:color, color:color, fillOpacity:0.9}).addTo(map);
        m.bindTooltip(label);
        window._osmMarkers.push(m);
      }));

      return {perStep, summaryCounts: summarize(perStep)};
    }

    function summarize(perStep){
      const counts = {roundabouts:0,traffic_signals:0,stops:0,crossings:0};
      const seenRound = new Set();
      perStep.forEach(ps => ps.found.forEach(f => {
        if(f.types.includes('roundabout')){
          const k = f.id;
          if(!seenRound.has(k)){ counts.roundabouts++; seenRound.add(k); }
        }
        if(f.types.includes('traffic_signal')) counts.traffic_signals++;
        if(f.types.includes('stop')) counts.stops++;
        if(f.types.includes('crossing')) counts.crossings++;
      }));
      return counts;
    }

    function renderTable(analysis){
      const tbody = document.querySelector('#stepsTable tbody');
      tbody.innerHTML='';
      analysis.perStep.forEach(ps => {
        const tr = document.createElement('tr');
        const foundStr = ps.found.length ? ps.found.map(f=> f.types.join('/') + ' ('+f.dist+'m)').join('; ') : '';
        tr.innerHTML = `<td>${ps.index}</td><td>${escapeHtml(ps.instruction)}</td><td>${escapeHtml(ps.street)}</td><td>${escapeHtml(ps.direction)}</td><td>${ps.distance}</td><td>${ps.duration}</td><td>${ps.latlon}</td><td>${escapeHtml(foundStr)}</td><td>${escapeHtml(ps.stepType)}</td>`;
        tbody.appendChild(tr);
      });
    }

    function updateSummary(analysis){
      const s = analysis.summaryCounts;
      document.getElementById('stats').innerHTML = `ðŸŒ€ Roundabouts: ${s.roundabouts} &nbsp;&nbsp; ðŸš¦ Traffic lights: ${s.traffic_signals} &nbsp;&nbsp; ðŸ›‘ Stops: ${s.stops} &nbsp;&nbsp; ðŸš¶ Crossings: ${s.crossings}`;
    }

    function exportCSV(){
      const rows = [];
      const headers = ['step','instruction','street','direction','distance_m','duration_s','latlon','found_object_types','step_type'];
      rows.push(headers.join(','));
      document.querySelectorAll('#stepsTable tbody tr').forEach(tr=>{
        const cols = Array.from(tr.querySelectorAll('td')).map(td=> `"${td.textContent.replace(/"/g,'""')}"`);
        rows.push(cols.join(','));
      });
      const csv = rows.join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='route_steps_v3.csv'; document.body.appendChild(a); a.click(); a.remove();
    }

    function exportJSON(){
      const data = [];
      document.querySelectorAll('#stepsTable tbody tr').forEach(tr=>{
        const tds = tr.querySelectorAll('td');
        data.push({step: tds[0].textContent, instruction: tds[1].textContent, street: tds[2].textContent, direction: tds[3].textContent, distance_m: Number(tds[4].textContent), duration_s: Number(tds[5].textContent), latlon: tds[6].textContent, found_object_types: tds[7].textContent, step_type: tds[8].textContent});
      });
      const blob = new Blob([JSON.stringify(data, null, 2)], {type:'application/json'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='route_steps_v3.json'; document.body.appendChild(a); a.click(); a.remove();
    }

    function escapeHtml(s){ if(!s) return ''; return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // PWA: register service worker
    if('serviceWorker' in navigator){
      navigator.serviceWorker.register('service-worker.js').then(()=>console.log('SW registered')).catch(e=>console.warn('SW failed',e));
    }
  </script>
</body>
</html>
